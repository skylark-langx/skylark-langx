{"version":3,"sources":["aspect.js"],"names":["define","undefined","nextId","aspect","type","target","methodName","advice","receiveArguments","dispatcher","existing","executionId","args","arguments","before","apply","this","next","around","results","after","id","newResults","call","signal","previous","advised","remove","advise"],"mappings":";;;;;;;AAAAA,UACE,WAEA,IAAIC,EAAWC,EAAS,EAqEtB,SAASC,EAAOC,GACZ,OAAO,SAASC,EAAQC,EAAYC,EAAQC,GACxC,IAAmCC,EAA/BC,EAAWL,EAAOC,GAClBI,GAAYA,EAASL,QAAUA,IAE/BA,EAAOC,GAAcG,EAAa,WAK9B,IAJA,IAAIE,EAAcT,EAEdU,EAAOC,UACPC,EAASL,EAAWK,OAClBA,GACFF,EAAOE,EAAOP,OAAOQ,MAAMC,KAAMJ,IAASA,EAC1CE,EAASA,EAAOG,KAGpB,GAAGR,EAAWS,OACV,IAAIC,EAAUV,EAAWS,OAAOX,OAAOS,KAAMJ,GAIjD,IADA,IAAIQ,EAAQX,EAAWW,MACjBA,GAASA,EAAMC,GAAKV,GAAY,CAClC,GAAGS,EAAMZ,iBAAiB,CACtB,IAAIc,EAAaF,EAAMb,OAAOQ,MAAMC,KAAMJ,GAE1CO,EAAUG,IAAerB,EAAYkB,EAAUG,OAE/CH,EAAUC,EAAMb,OAAOgB,KAAKP,KAAMG,EAASP,GAE/CQ,EAAQA,EAAMH,KAElB,OAAOE,GAERT,IACCD,EAAWS,QAAUX,OAAQ,SAASF,EAAQO,GAC1C,OAAOF,EAASK,MAAMV,EAAQO,MAGtCH,EAAWJ,OAASA,GAExB,IAAIc,EA3GZ,SAAgBV,EAAYL,EAAMG,EAAQC,GACtC,IAEIgB,EAFAC,EAAWhB,EAAWL,GACtBc,EAAiB,UAARd,EAEb,GAAGc,EAAO,CACN,IAAIQ,EAAUnB,EAAO,WACjB,OAAOkB,EAASlB,OAAOS,KAAMH,aAEjCW,GACIG,OAAQ,WACDD,IACCA,EAAUjB,EAAaF,EAAS,OAGxCA,OAAQ,SAASF,EAAQO,GACrB,OAAOc,EACHA,EAAQX,MAAMV,EAAQO,GACtBa,EAASlB,OAAOF,EAAQO,UAKpCY,GACIG,OAAQ,WACJ,GAAGH,EAAOjB,OAAO,CACb,IAAIkB,EAAWD,EAAOC,SAClBR,EAAOO,EAAOP,KACdA,GAASQ,GAGNA,EACCA,EAASR,KAAOA,EAEhBR,EAAWL,GAAQa,EAEpBA,IACCA,EAAKQ,SAAWA,WARbhB,EAAWL,GAatBK,EAAaF,EAASiB,EAAOjB,OAAS,OAG9Cc,GAAInB,IACJK,OAAQA,EACRC,iBAAkBA,GAG1B,GAAGiB,IAAaP,EACZ,GAAW,SAARd,EAAgB,CAGf,KAAMqB,EAASR,OAASQ,EAAWA,EAASR,QAC5CQ,EAASR,KAAOO,EAChBA,EAAOC,SAAWA,MACL,UAARrB,IAELK,EAAWL,GAAQoB,EACnBA,EAAOP,KAAOQ,EACdA,EAASA,SAAWD,QAIxBf,EAAWL,GAAQoB,EAEvB,OAAOA,EAyCWI,CAAQnB,GAAcC,EAAWN,EAAMG,EAAQC,GAE7D,OADAD,EAAS,KACFY,GAIf,OACIC,MAAOjB,EAAO,SAEde,OAAQf,EAAO,UAEfW,OAAQX,EAAO","file":"../aspect.js","sourcesContent":["define([\r\n],function(){\r\n\r\n  var undefined, nextId = 0;\r\n    function advise(dispatcher, type, advice, receiveArguments){\r\n        var previous = dispatcher[type];\r\n        var around = type == \"around\";\r\n        var signal;\r\n        if(around){\r\n            var advised = advice(function(){\r\n                return previous.advice(this, arguments);\r\n            });\r\n            signal = {\r\n                remove: function(){\r\n                    if(advised){\r\n                        advised = dispatcher = advice = null;\r\n                    }\r\n                },\r\n                advice: function(target, args){\r\n                    return advised ?\r\n                        advised.apply(target, args) :  // called the advised function\r\n                        previous.advice(target, args); // cancelled, skip to next one\r\n                }\r\n            };\r\n        }else{\r\n            // create the remove handler\r\n            signal = {\r\n                remove: function(){\r\n                    if(signal.advice){\r\n                        var previous = signal.previous;\r\n                        var next = signal.next;\r\n                        if(!next && !previous){\r\n                            delete dispatcher[type];\r\n                        }else{\r\n                            if(previous){\r\n                                previous.next = next;\r\n                            }else{\r\n                                dispatcher[type] = next;\r\n                            }\r\n                            if(next){\r\n                                next.previous = previous;\r\n                            }\r\n                        }\r\n\r\n                        // remove the advice to signal that this signal has been removed\r\n                        dispatcher = advice = signal.advice = null;\r\n                    }\r\n                },\r\n                id: nextId++,\r\n                advice: advice,\r\n                receiveArguments: receiveArguments\r\n            };\r\n        }\r\n        if(previous && !around){\r\n            if(type == \"after\"){\r\n                // add the listener to the end of the list\r\n                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\r\n                while(previous.next && (previous = previous.next)){}\r\n                previous.next = signal;\r\n                signal.previous = previous;\r\n            }else if(type == \"before\"){\r\n                // add to beginning\r\n                dispatcher[type] = signal;\r\n                signal.next = previous;\r\n                previous.previous = signal;\r\n            }\r\n        }else{\r\n            // around or first one just replaces\r\n            dispatcher[type] = signal;\r\n        }\r\n        return signal;\r\n    }\r\n    function aspect(type){\r\n        return function(target, methodName, advice, receiveArguments){\r\n            var existing = target[methodName], dispatcher;\r\n            if(!existing || existing.target != target){\r\n                // no dispatcher in place\r\n                target[methodName] = dispatcher = function(){\r\n                    var executionId = nextId;\r\n                    // before advice\r\n                    var args = arguments;\r\n                    var before = dispatcher.before;\r\n                    while(before){\r\n                        args = before.advice.apply(this, args) || args;\r\n                        before = before.next;\r\n                    }\r\n                    // around advice\r\n                    if(dispatcher.around){\r\n                        var results = dispatcher.around.advice(this, args);\r\n                    }\r\n                    // after advice\r\n                    var after = dispatcher.after;\r\n                    while(after && after.id < executionId){\r\n                        if(after.receiveArguments){\r\n                            var newResults = after.advice.apply(this, args);\r\n                            // change the return value only if a new value was returned\r\n                            results = newResults === undefined ? results : newResults;\r\n                        }else{\r\n                            results = after.advice.call(this, results, args);\r\n                        }\r\n                        after = after.next;\r\n                    }\r\n                    return results;\r\n                };\r\n                if(existing){\r\n                    dispatcher.around = {advice: function(target, args){\r\n                        return existing.apply(target, args);\r\n                    }};\r\n                }\r\n                dispatcher.target = target;\r\n            }\r\n            var results = advise((dispatcher || existing), type, advice, receiveArguments);\r\n            advice = null;\r\n            return results;\r\n        };\r\n    }\r\n\r\n    return {\r\n        after: aspect(\"after\"),\r\n \r\n        around: aspect(\"around\"),\r\n        \r\n        before: aspect(\"before\")\r\n    };\r\n});"]}