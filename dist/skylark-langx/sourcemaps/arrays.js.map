{"version":3,"sources":["arrays.js"],"names":["define","types","objects","filter","Array","prototype","isArrayLike","baseFindIndex","array","predicate","fromIndex","fromRight","length","index","baseIsNaN","value","flatten","result","i","item","j","push","baseIndexOf","compact","call","first","items","n","slice","inArray","indexOf","makeArray","obj","offset","startWith","concat","forEach","arr","fn","map","elements","callback","key","values","uniq","idx"],"mappings":";;;;;;;AAAAA,QACC,WACC,SAASC,EAAMC,GAChB,IAAIC,EAASC,MAAMC,UAAUF,OAC5BG,EAAcL,EAAMK,YAYlB,SAASC,EAAcC,EAAOC,EAAWC,EAAWC,GAIlD,IAHA,IAAIC,EAASJ,EAAMI,OACfC,EAAQH,GAAaC,EAAY,GAAK,GAElCA,EAAYE,MAAYA,EAAQD,GACtC,GAAIH,EAAUD,EAAMK,GAAQA,EAAOL,GACjC,OAAOK,EAGX,OAAQ,EAiCV,SAASC,EAAUC,GACjB,OAAOA,GAAUA,EAUnB,SAASC,EAAQR,GACb,GAAIF,EAAYE,GAAQ,CAEpB,IADA,IAAIS,KACKC,EAAI,EAAGA,EAAIV,EAAMI,OAAQM,IAAK,CACnC,IAAIC,EAAOX,EAAMU,GACjB,GAAIZ,EAAYa,GACZ,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAKP,OAAQQ,IAC7BH,EAAOI,KAAKF,EAAKC,SAGrBH,EAAOI,KAAKF,GAGpB,OAAOF,EAEP,OAAOT,EA0Ef,OACID,cAAeA,EAEfe,YA7HJ,SAAqBd,EAAOO,EAAOL,GACjC,GAAIK,GAAUA,EACZ,OAAOR,EAAcC,EAAOM,EAAWJ,GAKzC,IAHA,IAAIG,EAAQH,EAAY,EACpBE,EAASJ,EAAMI,SAEVC,EAAQD,GACf,GAAIJ,EAAMK,KAAWE,EACnB,OAAOF,EAGX,OAAQ,GAmHNU,QApGJ,SAAiBf,GACb,OAAOL,EAAOqB,KAAKhB,EAAO,SAASW,GAC/B,OAAe,MAARA,KAoGXM,MAAQ,SAASC,EAAMC,GACnB,OAAIA,EACOD,EAAME,MAAM,EAAED,GAEdD,EAAM,IAIrBV,QAASA,EAETa,QA1EJ,SAAiBV,EAAMX,GACnB,IAAKA,EACD,OAAQ,EAEZ,IAAIU,EAEJ,GAAIV,EAAMsB,QACN,OAAOtB,EAAMsB,QAAQX,GAIzB,IADAD,EAAIV,EAAMI,OACHM,KACH,GAAIV,EAAMU,KAAOC,EACb,OAAOD,EAIf,OAAQ,GA2DRa,UAxDJ,SAAmBC,EAAKC,EAAQC,GAC7B,OAAI5B,EAAY0B,IACPE,OAAiBC,OAAO/B,MAAMC,UAAUuB,MAAMJ,KAAKQ,EAAKC,GAAU,KAInED,IAoDPI,QAhDJ,SAAkBC,EAAKC,GACrB,GAAID,EAAID,QAAS,OAAOC,EAAID,QAAQE,GACpC,IAAK,IAAIpB,EAAI,EAAGA,EAAImB,EAAIzB,OAAQM,IAAKoB,EAAGD,EAAInB,GAAIA,IAgD9CqB,IA7CJ,SAAaC,EAAUC,GACnB,IAAI1B,EACAG,EAAGwB,EADIC,KAEX,GAAIrC,EAAYkC,GACZ,IAAKtB,EAAI,EAAGA,EAAIsB,EAAS5B,OAAQM,IAEhB,OADbH,EAAQ0B,EAASjB,KAAKgB,EAAStB,GAAIsB,EAAStB,GAAIA,KAC7ByB,EAAOtB,KAAKN,QAGnC,IAAK2B,KAAOF,EAEK,OADbzB,EAAQ0B,EAASjB,KAAKgB,EAASE,GAAMF,EAASE,GAAMA,KACjCC,EAAOtB,KAAKN,GAEvC,OAAOC,EAAQ2B,IAkCfC,KA/BJ,SAAcpC,GACV,OAAOL,EAAOqB,KAAKhB,EAAO,SAASW,EAAM0B,GACrC,OAAOrC,EAAMsB,QAAQX,IAAS0B","file":"../arrays.js","sourcesContent":["define([\r\n\t\"./types\"\r\n],function(types,objects){\r\n\tvar filter = Array.prototype.filter,\r\n\t\tisArrayLike = types.isArrayLike;\r\n\r\n    /**\r\n     * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n     * support for iteratee shorthands.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\r\n      var length = array.length,\r\n          index = fromIndex + (fromRight ? 1 : -1);\r\n\r\n      while ((fromRight ? index-- : ++index < length)) {\r\n        if (predicate(array[index], index, array)) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseIndexOf(array, value, fromIndex) {\r\n      if (value !== value) {\r\n        return baseFindIndex(array, baseIsNaN, fromIndex);\r\n      }\r\n      var index = fromIndex - 1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (array[index] === value) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `isNaN` without support for number objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n     */\r\n    function baseIsNaN(value) {\r\n      return value !== value;\r\n    }\r\n\r\n\r\n    function compact(array) {\r\n        return filter.call(array, function(item) {\r\n            return item != null;\r\n        });\r\n    }\r\n\r\n    function flatten(array) {\r\n        if (isArrayLike(array)) {\r\n            var result = [];\r\n            for (var i = 0; i < array.length; i++) {\r\n                var item = array[i];\r\n                if (isArrayLike(item)) {\r\n                    for (var j = 0; j < item.length; j++) {\r\n                        result.push(item[j]);\r\n                    }\r\n                } else {\r\n                    result.push(item);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            return array;\r\n        }\r\n        //return array.length > 0 ? concat.apply([], array) : array;\r\n    }\r\n\r\n    function grep(array, callback) {\r\n        var out = [];\r\n\r\n        each(array, function(i, item) {\r\n            if (callback(item, i)) {\r\n                out.push(item);\r\n            }\r\n        });\r\n\r\n        return out;\r\n    }\r\n\r\n    function inArray(item, array) {\r\n        if (!array) {\r\n            return -1;\r\n        }\r\n        var i;\r\n\r\n        if (array.indexOf) {\r\n            return array.indexOf(item);\r\n        }\r\n\r\n        i = array.length;\r\n        while (i--) {\r\n            if (array[i] === item) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function makeArray(obj, offset, startWith) {\r\n       if (isArrayLike(obj) ) {\r\n        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));\r\n      }\r\n\r\n      // array of single index\r\n      return [ obj ];             \r\n    }\r\n\r\n\r\n    function forEach (arr, fn) {\r\n      if (arr.forEach) return arr.forEach(fn)\r\n      for (var i = 0; i < arr.length; i++) fn(arr[i], i);\r\n    }\r\n\r\n    function map(elements, callback) {\r\n        var value, values = [],\r\n            i, key\r\n        if (isArrayLike(elements))\r\n            for (i = 0; i < elements.length; i++) {\r\n                value = callback.call(elements[i], elements[i], i);\r\n                if (value != null) values.push(value)\r\n            }\r\n        else\r\n            for (key in elements) {\r\n                value = callback.call(elements[key], elements[key], key);\r\n                if (value != null) values.push(value)\r\n            }\r\n        return flatten(values)\r\n    }\r\n\r\n    function uniq(array) {\r\n        return filter.call(array, function(item, idx) {\r\n            return array.indexOf(item) == idx;\r\n        })\r\n    }\r\n\r\n    return {\r\n        baseFindIndex: baseFindIndex,\r\n\r\n        baseIndexOf : baseIndexOf,\r\n        \r\n        compact: compact,\r\n\r\n        first : function(items,n) {\r\n            if (n) {\r\n                return items.slice(0,n);\r\n            } else {\r\n                return items[0];\r\n            }\r\n        },\r\n\r\n        flatten: flatten,\r\n\r\n        inArray: inArray,\r\n\r\n        makeArray: makeArray,\r\n\r\n        forEach : forEach,\r\n\r\n        map : map,\r\n        \r\n        uniq : uniq\r\n\r\n    }\r\n});"]}