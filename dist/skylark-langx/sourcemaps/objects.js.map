{"version":3,"sources":["objects.js"],"names":["define","types","createAssigner","keysFunc","defaults","obj","length","arguments","Object","index","source","keys","l","i","key","allKeys","isObject","push","each","callback","undef","value","hasOwnProperty","call","this","has","path","isArray","isEqual","a","b","eq","isMatch","object","attrs","_mixin","target","deep","safe","undefined","isPlainObject","_parseMixinArgs","args","params","slice","shift","isBoolean","pop","sources","mixin","apply","forEach","removeItem","items","item","idx","indexOf","splice","result","fallback","isFunction","prop","safeMixin","values","_","Array","clone","src","checkCloneMethod","copy","deepEq","prototype","SymbolProto","Symbol","aStack","bStack","type","className","toString","valueOf","areArrays","aCtor","constructor","bCtor"],"mappings":"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","file":"../objects.js","sourcesContent":["define([\r\n\t\"./types\"\r\n],function(types){\r\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\r\n        slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean,\r\n        isFunction = types.isFunction,\r\n\t\tisObject = types.isObject,\r\n\t\tisPlainObject = types.isPlainObject,\r\n\t\tisArray = types.isArray;\r\n\r\n     // An internal function for creating assigner functions.\r\n    function createAssigner(keysFunc, defaults) {\r\n        return function(obj) {\r\n          var length = arguments.length;\r\n          if (defaults) obj = Object(obj);  \r\n          if (length < 2 || obj == null) return obj;\r\n          for (var index = 1; index < length; index++) {\r\n            var source = arguments[index],\r\n                keys = keysFunc(source),\r\n                l = keys.length;\r\n            for (var i = 0; i < l; i++) {\r\n              var key = keys[i];\r\n              if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n            }\r\n          }\r\n          return obj;\r\n       };\r\n    }\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function each(obj, callback) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if (callback.call(value, key, value) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if (callback.call(value, i, value) === false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function has(obj, path) {\r\n        if (!isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n                if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                if (isArray(source[key]) && !isArray(target[key])) {\r\n                    target[key] = [];\r\n                }\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    function removeItem(items, item) {\r\n        if (isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function result(obj, path, fallback) {\r\n        if (!isArray(path)) {\r\n            path = [path]\r\n        };\r\n        var length = path.length;\r\n        if (!length) {\r\n          return isFunction(fallback) ? fallback.call(obj) : fallback;\r\n        }\r\n        for (var i = 0; i < length; i++) {\r\n          var prop = obj == null ? void 0 : obj[path[i]];\r\n          if (prop === void 0) {\r\n            prop = fallback;\r\n            i = length; // Ensure we don't continue iterating.\r\n          }\r\n          obj = isFunction(prop) ? prop.call(obj) : prop;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = _.keys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n\r\n    \r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return {\r\n        allKeys: allKeys,\r\n\r\n        clone: clone,\r\n\r\n        defaults : createAssigner(allKeys, true),\r\n\r\n        each : each,\r\n\r\n        has: has,\r\n\r\n        isEqual: isEqual,\r\n\r\n        isMatch: isMatch,\r\n\r\n        keys: keys,\r\n\r\n        mixin: mixin,\r\n\r\n        removeItem: removeItem,\r\n\r\n        result : result,\r\n        \r\n        safeMixin: safeMixin,\r\n\r\n        values: values\r\n    };\r\n\r\n});"]}