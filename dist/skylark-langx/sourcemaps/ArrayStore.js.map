{"version":3,"sources":["ArrayStore.js"],"names":["define","klass","QueryResults","results","isPromise","then","addIterativeMethod","method","args","arguments","result","Deferred","when","Array","prototype","apply","Object","delegate","total","length","klassName","queryEngine","query","options","Error","queryObject","object","key","required","test","this","execute","array","arr","callback","thisObject","value","i","l","out","split","cache","buildFn","call","push","filter","sortSet","sort","a","b","aValue","attribute","bValue","valueOf","descending","start","count","slice","Infinity","matches","idProperty","get","id","data","index","getIdentity","put","Math","random","overwrite","add","remove","splice","setData","items","identifier","init"],"mappings":"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","file":"../ArrayStore.js","sourcesContent":["define([\r\n    \"./klass\"\r\n],function(klass){\r\n    var SimpleQueryEngine = function(query, options){\r\n        // summary:\r\n        //      Simple query engine that matches using filter functions, named filter\r\n        //      functions or objects by name-value on a query object hash\r\n        //\r\n        // description:\r\n        //      The SimpleQueryEngine provides a way of getting a QueryResults through\r\n        //      the use of a simple object hash as a filter.  The hash will be used to\r\n        //      match properties on data objects with the corresponding value given. In\r\n        //      other words, only exact matches will be returned.\r\n        //\r\n        //      This function can be used as a template for more complex query engines;\r\n        //      for example, an engine can be created that accepts an object hash that\r\n        //      contains filtering functions, or a string that gets evaluated, etc.\r\n        //\r\n        //      When creating a new dojo.store, simply set the store's queryEngine\r\n        //      field as a reference to this function.\r\n        //\r\n        // query: Object\r\n        //      An object hash with fields that may match fields of items in the store.\r\n        //      Values in the hash will be compared by normal == operator, but regular expressions\r\n        //      or any object that provides a test() method are also supported and can be\r\n        //      used to match strings by more complex expressions\r\n        //      (and then the regex's or object's test() method will be used to match values).\r\n        //\r\n        // options: dojo/store/api/Store.QueryOptions?\r\n        //      An object that contains optional information such as sort, start, and count.\r\n        //\r\n        // returns: Function\r\n        //      A function that caches the passed query under the field \"matches\".  See any\r\n        //      of the \"query\" methods on dojo.stores.\r\n        //\r\n        // example:\r\n        //      Define a store with a reference to this engine, and set up a query method.\r\n        //\r\n        //  |   var myStore = function(options){\r\n        //  |       //  ...more properties here\r\n        //  |       this.queryEngine = SimpleQueryEngine;\r\n        //  |       //  define our query method\r\n        //  |       this.query = function(query, options){\r\n        //  |           return QueryResults(this.queryEngine(query, options)(this.data));\r\n        //  |       };\r\n        //  |   };\r\n\r\n        // create our matching query function\r\n        switch(typeof query){\r\n            default:\r\n                throw new Error(\"Can not query with a \" + typeof query);\r\n            case \"object\": case \"undefined\":\r\n                var queryObject = query;\r\n                query = function(object){\r\n                    for(var key in queryObject){\r\n                        var required = queryObject[key];\r\n                        if(required && required.test){\r\n                            // an object can provide a test method, which makes it work with regex\r\n                            if(!required.test(object[key], object)){\r\n                                return false;\r\n                            }\r\n                        }else if(required != object[key]){\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                };\r\n                break;\r\n            case \"string\":\r\n                // named query\r\n                if(!this[query]){\r\n                    throw new Error(\"No filter function \" + query + \" was found in store\");\r\n                }\r\n                query = this[query];\r\n                // fall through\r\n            case \"function\":\r\n                // fall through\r\n        }\r\n        \r\n        function filter(arr, callback, thisObject){\r\n            // summary:\r\n            //      Returns a new Array with those items from arr that match the\r\n            //      condition implemented by callback.\r\n            // arr: Array\r\n            //      the array to iterate over.\r\n            // callback: Function|String\r\n            //      a function that is invoked with three arguments (item,\r\n            //      index, array). The return of this function is expected to\r\n            //      be a boolean which determines whether the passed-in item\r\n            //      will be included in the returned array.\r\n            // thisObject: Object?\r\n            //      may be used to scope the call to callback\r\n            // returns: Array\r\n            // description:\r\n            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\r\n            //      run over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\r\n            //      For more details, see:\r\n            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\r\n            // example:\r\n            //  | // returns [2, 3, 4]\r\n            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });\r\n\r\n            // TODO: do we need \"Ctr\" here like in map()?\r\n            var i = 0, l = arr && arr.length || 0, out = [], value;\r\n            if(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n            if(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n            if(thisObject){\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback.call(thisObject, value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }else{\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback(value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }\r\n            return out; // Array\r\n        }\r\n\r\n        function execute(array){\r\n            // execute the whole query, first we filter\r\n            var results = filter(array, query);\r\n            // next we sort\r\n            var sortSet = options && options.sort;\r\n            if(sortSet){\r\n                results.sort(typeof sortSet == \"function\" ? sortSet : function(a, b){\r\n                    for(var sort, i=0; sort = sortSet[i]; i++){\r\n                        var aValue = a[sort.attribute];\r\n                        var bValue = b[sort.attribute];\r\n                        // valueOf enables proper comparison of dates\r\n                        aValue = aValue != null ? aValue.valueOf() : aValue;\r\n                        bValue = bValue != null ? bValue.valueOf() : bValue;\r\n                        if (aValue != bValue){\r\n                            // modified by lwf 2016/07/09\r\n                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                        }\r\n                    }\r\n                    return 0;\r\n                });\r\n            }\r\n            // now we paginate\r\n            if(options && (options.start || options.count)){\r\n                var total = results.length;\r\n                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));\r\n                results.total = total;\r\n            }\r\n            return results;\r\n        }\r\n        execute.matches = query;\r\n        return execute;\r\n    };\r\n\r\n    var QueryResults = function(results){\r\n        // summary:\r\n        //      A function that wraps the results of a store query with additional\r\n        //      methods.\r\n        // description:\r\n        //      QueryResults is a basic wrapper that allows for array-like iteration\r\n        //      over any kind of returned data from a query.  While the simplest store\r\n        //      will return a plain array of data, other stores may return deferreds or\r\n        //      promises; this wrapper makes sure that *all* results can be treated\r\n        //      the same.\r\n        //\r\n        //      Additional methods include `forEach`, `filter` and `map`.\r\n        // results: Array|dojo/promise/Promise\r\n        //      The result set as an array, or a promise for an array.\r\n        // returns:\r\n        //      An array-like object that can be used for iterating over.\r\n        // example:\r\n        //      Query a store and iterate over the results.\r\n        //\r\n        //  |   store.query({ prime: true }).forEach(function(item){\r\n        //  |       //  do something\r\n        //  |   });\r\n\r\n        if(!results){\r\n            return results;\r\n        }\r\n\r\n        var isPromise = !!results.then;\r\n        // if it is a promise it may be frozen\r\n        if(isPromise){\r\n            results = Object.delegate(results);\r\n        }\r\n        function addIterativeMethod(method){\r\n            // Always add the iterative methods so a QueryResults is\r\n            // returned whether the environment is ES3 or ES5\r\n            results[method] = function(){\r\n                var args = arguments;\r\n                var result = Deferred.when(results, function(results){\r\n                    //Array.prototype.unshift.call(args, results);\r\n                    return QueryResults(Array.prototype[method].apply(results, args));\r\n                });\r\n                // forEach should only return the result of when()\r\n                // when we're wrapping a promise\r\n                if(method !== \"forEach\" || isPromise){\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        addIterativeMethod(\"forEach\");\r\n        addIterativeMethod(\"filter\");\r\n        addIterativeMethod(\"map\");\r\n        if(results.total == null){\r\n            results.total = Deferred.when(results, function(results){\r\n                return results.length;\r\n            });\r\n        }\r\n        return results; // Object\r\n    };\r\n\r\n    var ArrayStore = klass({\r\n        \"klassName\": \"ArrayStore\",\r\n\r\n        \"queryEngine\": SimpleQueryEngine,\r\n        \r\n        \"idProperty\": \"id\",\r\n\r\n\r\n        get: function(id){\r\n            // summary:\r\n            //      Retrieves an object by its identity\r\n            // id: Number\r\n            //      The identity to use to lookup the object\r\n            // returns: Object\r\n            //      The object in the store that matches the given id.\r\n            return this.data[this.index[id]];\r\n        },\r\n\r\n        getIdentity: function(object){\r\n            return object[this.idProperty];\r\n        },\r\n\r\n        put: function(object, options){\r\n            var data = this.data,\r\n                index = this.index,\r\n                idProperty = this.idProperty;\r\n            var id = object[idProperty] = (options && \"id\" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();\r\n            if(id in index){\r\n                // object exists\r\n                if(options && options.overwrite === false){\r\n                    throw new Error(\"Object already exists\");\r\n                }\r\n                // replace the entry in data\r\n                data[index[id]] = object;\r\n            }else{\r\n                // add the new object\r\n                index[id] = data.push(object) - 1;\r\n            }\r\n            return id;\r\n        },\r\n\r\n        add: function(object, options){\r\n            (options = options || {}).overwrite = false;\r\n            // call put with overwrite being false\r\n            return this.put(object, options);\r\n        },\r\n\r\n        remove: function(id){\r\n            // summary:\r\n            //      Deletes an object by its identity\r\n            // id: Number\r\n            //      The identity to use to delete the object\r\n            // returns: Boolean\r\n            //      Returns true if an object was removed, falsy (undefined) if no object matched the id\r\n            var index = this.index;\r\n            var data = this.data;\r\n            if(id in index){\r\n                data.splice(index[id], 1);\r\n                // now we have to reindex\r\n                this.setData(data);\r\n                return true;\r\n            }\r\n        },\r\n        query: function(query, options){\r\n            // summary:\r\n            //      Queries the store for objects.\r\n            // query: Object\r\n            //      The query to use for retrieving objects from the store.\r\n            // options: dojo/store/api/Store.QueryOptions?\r\n            //      The optional arguments to apply to the resultset.\r\n            // returns: dojo/store/api/Store.QueryResults\r\n            //      The results of the query, extended with iterative methods.\r\n            //\r\n            // example:\r\n            //      Given the following store:\r\n            //\r\n            //  |   var store = new Memory({\r\n            //  |       data: [\r\n            //  |           {id: 1, name: \"one\", prime: false },\r\n            //  |           {id: 2, name: \"two\", even: true, prime: true},\r\n            //  |           {id: 3, name: \"three\", prime: true},\r\n            //  |           {id: 4, name: \"four\", even: true, prime: false},\r\n            //  |           {id: 5, name: \"five\", prime: true}\r\n            //  |       ]\r\n            //  |   });\r\n            //\r\n            //  ...find all items where \"prime\" is true:\r\n            //\r\n            //  |   var results = store.query({ prime: true });\r\n            //\r\n            //  ...or find all items where \"even\" is true:\r\n            //\r\n            //  |   var results = store.query({ even: true });\r\n            return QueryResults(this.queryEngine(query, options)(this.data));\r\n        },\r\n\r\n        setData: function(data){\r\n            // summary:\r\n            //      Sets the given data as the source for this store, and indexes it\r\n            // data: Object[]\r\n            //      An array of objects to use as the source of data.\r\n            if(data.items){\r\n                // just for convenience with the data format IFRS expects\r\n                this.idProperty = data.identifier || this.idProperty;\r\n                data = this.data = data.items;\r\n            }else{\r\n                this.data = data;\r\n            }\r\n            this.index = {};\r\n            for(var i = 0, l = data.length; i < l; i++){\r\n                this.index[data[i][this.idProperty]] = i;\r\n            }\r\n        },\r\n\r\n        init: function(options) {\r\n            for(var i in options){\r\n                this[i] = options[i];\r\n            }\r\n            this.setData(this.data || []);\r\n        }\r\n\r\n    });\r\n\r\n\treturn ArrayStore;\r\n});"]}