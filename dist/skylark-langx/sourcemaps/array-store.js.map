{"version":3,"sources":["array-store.js"],"names":["define","klass","QueryResults","results","isPromise","then","Object","delegate","addIterativeMethod","total","Deferred","when","length","method","args","arguments","result","Array","prototype","apply","klassName","queryEngine","query","options","Error","queryObject","object","key","required","test","this","execute","array","arr","callback","thisObject","value","i","l","out","split","cache","buildFn","call","push","sortSet","sort","a","b","aValue","attribute","bValue","valueOf","descending","start","count","slice","Infinity","matches","idProperty","get","id","data","index","getIdentity","put","Math","random","overwrite","add","remove","splice","setData","items","identifier","init"],"mappings":"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","file":"../array-store.js","sourcesContent":["define([\r\n    \"./klass\"\r\n],function(klass){\r\n    var SimpleQueryEngine = function(query, options){\r\n        // summary:\r\n        //      Simple query engine that matches using filter functions, named filter\r\n        //      functions or objects by name-value on a query object hash\r\n        //\r\n        // description:\r\n        //      The SimpleQueryEngine provides a way of getting a QueryResults through\r\n        //      the use of a simple object hash as a filter.  The hash will be used to\r\n        //      match properties on data objects with the corresponding value given. In\r\n        //      other words, only exact matches will be returned.\r\n        //\r\n        //      This function can be used as a template for more complex query engines;\r\n        //      for example, an engine can be created that accepts an object hash that\r\n        //      contains filtering functions, or a string that gets evaluated, etc.\r\n        //\r\n        //      When creating a new dojo.store, simply set the store's queryEngine\r\n        //      field as a reference to this function.\r\n        //\r\n        // query: Object\r\n        //      An object hash with fields that may match fields of items in the store.\r\n        //      Values in the hash will be compared by normal == operator, but regular expressions\r\n        //      or any object that provides a test() method are also supported and can be\r\n        //      used to match strings by more complex expressions\r\n        //      (and then the regex's or object's test() method will be used to match values).\r\n        //\r\n        // options: dojo/store/api/Store.QueryOptions?\r\n        //      An object that contains optional information such as sort, start, and count.\r\n        //\r\n        // returns: Function\r\n        //      A function that caches the passed query under the field \"matches\".  See any\r\n        //      of the \"query\" methods on dojo.stores.\r\n        //\r\n        // example:\r\n        //      Define a store with a reference to this engine, and set up a query method.\r\n        //\r\n        //  |   var myStore = function(options){\r\n        //  |       //  ...more properties here\r\n        //  |       this.queryEngine = SimpleQueryEngine;\r\n        //  |       //  define our query method\r\n        //  |       this.query = function(query, options){\r\n        //  |           return QueryResults(this.queryEngine(query, options)(this.data));\r\n        //  |       };\r\n        //  |   };\r\n\r\n        // create our matching query function\r\n        switch(typeof query){\r\n            default:\r\n                throw new Error(\"Can not query with a \" + typeof query);\r\n            case \"object\": case \"undefined\":\r\n                var queryObject = query;\r\n                query = function(object){\r\n                    for(var key in queryObject){\r\n                        var required = queryObject[key];\r\n                        if(required && required.test){\r\n                            // an object can provide a test method, which makes it work with regex\r\n                            if(!required.test(object[key], object)){\r\n                                return false;\r\n                            }\r\n                        }else if(required != object[key]){\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                };\r\n                break;\r\n            case \"string\":\r\n                // named query\r\n                if(!this[query]){\r\n                    throw new Error(\"No filter function \" + query + \" was found in store\");\r\n                }\r\n                query = this[query];\r\n                // fall through\r\n            case \"function\":\r\n                // fall through\r\n        }\r\n        \r\n        function filter(arr, callback, thisObject){\r\n            // summary:\r\n            //      Returns a new Array with those items from arr that match the\r\n            //      condition implemented by callback.\r\n            // arr: Array\r\n            //      the array to iterate over.\r\n            // callback: Function|String\r\n            //      a function that is invoked with three arguments (item,\r\n            //      index, array). The return of this function is expected to\r\n            //      be a boolean which determines whether the passed-in item\r\n            //      will be included in the returned array.\r\n            // thisObject: Object?\r\n            //      may be used to scope the call to callback\r\n            // returns: Array\r\n            // description:\r\n            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\r\n            //      run over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\r\n            //      For more details, see:\r\n            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\r\n            // example:\r\n            //  | // returns [2, 3, 4]\r\n            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });\r\n\r\n            // TODO: do we need \"Ctr\" here like in map()?\r\n            var i = 0, l = arr && arr.length || 0, out = [], value;\r\n            if(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n            if(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n            if(thisObject){\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback.call(thisObject, value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }else{\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback(value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }\r\n            return out; // Array\r\n        }\r\n\r\n        function execute(array){\r\n            // execute the whole query, first we filter\r\n            var results = filter(array, query);\r\n            // next we sort\r\n            var sortSet = options && options.sort;\r\n            if(sortSet){\r\n                results.sort(typeof sortSet == \"function\" ? sortSet : function(a, b){\r\n                    for(var sort, i=0; sort = sortSet[i]; i++){\r\n                        var aValue = a[sort.attribute];\r\n                        var bValue = b[sort.attribute];\r\n                        // valueOf enables proper comparison of dates\r\n                        aValue = aValue != null ? aValue.valueOf() : aValue;\r\n                        bValue = bValue != null ? bValue.valueOf() : bValue;\r\n                        if (aValue != bValue){\r\n                            // modified by lwf 2016/07/09\r\n                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                        }\r\n                    }\r\n                    return 0;\r\n                });\r\n            }\r\n            // now we paginate\r\n            if(options && (options.start || options.count)){\r\n                var total = results.length;\r\n                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));\r\n                results.total = total;\r\n            }\r\n            return results;\r\n        }\r\n        execute.matches = query;\r\n        return execute;\r\n    };\r\n\r\n    var QueryResults = function(results){\r\n        // summary:\r\n        //      A function that wraps the results of a store query with additional\r\n        //      methods.\r\n        // description:\r\n        //      QueryResults is a basic wrapper that allows for array-like iteration\r\n        //      over any kind of returned data from a query.  While the simplest store\r\n        //      will return a plain array of data, other stores may return deferreds or\r\n        //      promises; this wrapper makes sure that *all* results can be treated\r\n        //      the same.\r\n        //\r\n        //      Additional methods include `forEach`, `filter` and `map`.\r\n        // results: Array|dojo/promise/Promise\r\n        //      The result set as an array, or a promise for an array.\r\n        // returns:\r\n        //      An array-like object that can be used for iterating over.\r\n        // example:\r\n        //      Query a store and iterate over the results.\r\n        //\r\n        //  |   store.query({ prime: true }).forEach(function(item){\r\n        //  |       //  do something\r\n        //  |   });\r\n\r\n        if(!results){\r\n            return results;\r\n        }\r\n\r\n        var isPromise = !!results.then;\r\n        // if it is a promise it may be frozen\r\n        if(isPromise){\r\n            results = Object.delegate(results);\r\n        }\r\n        function addIterativeMethod(method){\r\n            // Always add the iterative methods so a QueryResults is\r\n            // returned whether the environment is ES3 or ES5\r\n            results[method] = function(){\r\n                var args = arguments;\r\n                var result = Deferred.when(results, function(results){\r\n                    //Array.prototype.unshift.call(args, results);\r\n                    return QueryResults(Array.prototype[method].apply(results, args));\r\n                });\r\n                // forEach should only return the result of when()\r\n                // when we're wrapping a promise\r\n                if(method !== \"forEach\" || isPromise){\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        addIterativeMethod(\"forEach\");\r\n        addIterativeMethod(\"filter\");\r\n        addIterativeMethod(\"map\");\r\n        if(results.total == null){\r\n            results.total = Deferred.when(results, function(results){\r\n                return results.length;\r\n            });\r\n        }\r\n        return results; // Object\r\n    };\r\n\r\n    var ArrayStore = klass({\r\n        \"klassName\": \"ArrayStore\",\r\n\r\n        \"queryEngine\": SimpleQueryEngine,\r\n        \r\n        \"idProperty\": \"id\",\r\n\r\n\r\n        get: function(id){\r\n            // summary:\r\n            //      Retrieves an object by its identity\r\n            // id: Number\r\n            //      The identity to use to lookup the object\r\n            // returns: Object\r\n            //      The object in the store that matches the given id.\r\n            return this.data[this.index[id]];\r\n        },\r\n\r\n        getIdentity: function(object){\r\n            return object[this.idProperty];\r\n        },\r\n\r\n        put: function(object, options){\r\n            var data = this.data,\r\n                index = this.index,\r\n                idProperty = this.idProperty;\r\n            var id = object[idProperty] = (options && \"id\" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();\r\n            if(id in index){\r\n                // object exists\r\n                if(options && options.overwrite === false){\r\n                    throw new Error(\"Object already exists\");\r\n                }\r\n                // replace the entry in data\r\n                data[index[id]] = object;\r\n            }else{\r\n                // add the new object\r\n                index[id] = data.push(object) - 1;\r\n            }\r\n            return id;\r\n        },\r\n\r\n        add: function(object, options){\r\n            (options = options || {}).overwrite = false;\r\n            // call put with overwrite being false\r\n            return this.put(object, options);\r\n        },\r\n\r\n        remove: function(id){\r\n            // summary:\r\n            //      Deletes an object by its identity\r\n            // id: Number\r\n            //      The identity to use to delete the object\r\n            // returns: Boolean\r\n            //      Returns true if an object was removed, falsy (undefined) if no object matched the id\r\n            var index = this.index;\r\n            var data = this.data;\r\n            if(id in index){\r\n                data.splice(index[id], 1);\r\n                // now we have to reindex\r\n                this.setData(data);\r\n                return true;\r\n            }\r\n        },\r\n        query: function(query, options){\r\n            // summary:\r\n            //      Queries the store for objects.\r\n            // query: Object\r\n            //      The query to use for retrieving objects from the store.\r\n            // options: dojo/store/api/Store.QueryOptions?\r\n            //      The optional arguments to apply to the resultset.\r\n            // returns: dojo/store/api/Store.QueryResults\r\n            //      The results of the query, extended with iterative methods.\r\n            //\r\n            // example:\r\n            //      Given the following store:\r\n            //\r\n            //  |   var store = new Memory({\r\n            //  |       data: [\r\n            //  |           {id: 1, name: \"one\", prime: false },\r\n            //  |           {id: 2, name: \"two\", even: true, prime: true},\r\n            //  |           {id: 3, name: \"three\", prime: true},\r\n            //  |           {id: 4, name: \"four\", even: true, prime: false},\r\n            //  |           {id: 5, name: \"five\", prime: true}\r\n            //  |       ]\r\n            //  |   });\r\n            //\r\n            //  ...find all items where \"prime\" is true:\r\n            //\r\n            //  |   var results = store.query({ prime: true });\r\n            //\r\n            //  ...or find all items where \"even\" is true:\r\n            //\r\n            //  |   var results = store.query({ even: true });\r\n            return QueryResults(this.queryEngine(query, options)(this.data));\r\n        },\r\n\r\n        setData: function(data){\r\n            // summary:\r\n            //      Sets the given data as the source for this store, and indexes it\r\n            // data: Object[]\r\n            //      An array of objects to use as the source of data.\r\n            if(data.items){\r\n                // just for convenience with the data format IFRS expects\r\n                this.idProperty = data.identifier || this.idProperty;\r\n                data = this.data = data.items;\r\n            }else{\r\n                this.data = data;\r\n            }\r\n            this.index = {};\r\n            for(var i = 0, l = data.length; i < l; i++){\r\n                this.index[data[i][this.idProperty]] = i;\r\n            }\r\n        },\r\n\r\n        init: function(options) {\r\n            for(var i in options){\r\n                this[i] = options[i];\r\n            }\r\n            this.setData(this.data || []);\r\n        }\r\n\r\n    });\r\n\r\n\treturn ArrayStore;\r\n});"]}