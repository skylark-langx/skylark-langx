{"version":3,"sources":["klass.js"],"names":["define","arrays","objects","types","uniq","has","mixin","isArray","isDefined","f1","extendClass","ctor","props","options","proto","prototype","_super","superclass","noOverrided","name","prop","_constructor","fn","superFn","tmp","this","overrided","ret","apply","arguments","Object","defineProperty","serialMixins","mixins","result","forEach","Error","clss","unshift","concat","filter","cls","clsMixines","i","length","mergeMixins","newCtor","xtor","Function","create","__proto__","__mixin__","_construct","init","createClass","parent","innerParent","klassName","constructor","__mixins__","partial","inherit"],"mappings":"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","file":"../klass.js","sourcesContent":["define([\r\n    \"./arrays\",\r\n    \"./objects\",\r\n    \"./types\"\r\n],function(arrays,objects,types){\r\n    var uniq = arrays.uniq,\r\n        has = objects.has,\r\n        mixin = objects.mixin,\r\n        isArray = types.isArray,\r\n        isDefined = types.isDefined;\r\n    \r\n    function inherit(ctor, base) {\r\n        var f = function() {};\r\n        f.prototype = base.prototype;\r\n\r\n        ctor.prototype = new f();\r\n    }\r\n\r\n    var f1 = function() {\r\n        function extendClass(ctor, props, options) {\r\n            // Copy the properties to the prototype of the class.\r\n            var proto = ctor.prototype,\r\n                _super = ctor.superclass.prototype,\r\n                noOverrided = options && options.noOverrided;\r\n\r\n            for (var name in props) {\r\n                if (name === \"constructor\") {\r\n                    continue;\r\n                }\r\n\r\n                // Check if we're overwriting an existing function\r\n                var prop = props[name];\r\n                if (typeof props[name] == \"function\") {\r\n                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == \"function\" ?\r\n                          (function(name, fn, superFn) {\r\n                            return function() {\r\n                                var tmp = this.overrided;\r\n\r\n                                // Add a new ._super() method that is the same method\r\n                                // but on the super-class\r\n                                this.overrided = superFn;\r\n\r\n                                // The method only need to be bound temporarily, so we\r\n                                // remove it when we're done executing\r\n                                var ret = fn.apply(this, arguments);\r\n\r\n                                this.overrided = tmp;\r\n\r\n                                return ret;\r\n                            };\r\n                        })(name, prop, _super[name]) :\r\n                        prop;\r\n                } else if (typeof prop == \"object\" && prop!==null && (prop.get)) {\r\n                    Object.defineProperty(proto,name,prop);\r\n                } else {\r\n                    proto[name] = prop;\r\n                }\r\n            }\r\n            return ctor;\r\n        }\r\n\r\n        function serialMixins(ctor,mixins) {\r\n            var result = [];\r\n\r\n            mixins.forEach(function(mixin){\r\n                if (has(mixin,\"__mixins__\")) {\r\n                     throw new Error(\"nested mixins\");\r\n                }\r\n                var clss = [];\r\n                while (mixin) {\r\n                    clss.unshift(mixin);\r\n                    mixin = mixin.superclass;\r\n                }\r\n                result = result.concat(clss);\r\n            });\r\n\r\n            result = uniq(result);\r\n\r\n            result = result.filter(function(mixin){\r\n                var cls = ctor;\r\n                while (cls) {\r\n                    if (mixin === cls) {\r\n                        return false;\r\n                    }\r\n                    if (has(cls,\"__mixins__\")) {\r\n                        var clsMixines = cls[\"__mixins__\"];\r\n                        for (var i=0; i<clsMixines.length;i++) {\r\n                            if (clsMixines[i]===mixin) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                    cls = cls.superclass;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            if (result.length>0) {\r\n                return result;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        function mergeMixins(ctor,mixins) {\r\n            var newCtor =ctor;\r\n            for (var i=0;i<mixins.length;i++) {\r\n                var xtor = new Function();\r\n                xtor.prototype = Object.create(newCtor.prototype);\r\n                xtor.__proto__ = newCtor;\r\n                xtor.superclass = null;\r\n                mixin(xtor.prototype,mixins[i].prototype);\r\n                xtor.prototype.__mixin__ = mixins[i];\r\n                newCtor = xtor;\r\n            }\r\n\r\n            return newCtor;\r\n        }\r\n\r\n        function _constructor ()  {\r\n            if (this._construct) {\r\n                return this._construct.apply(this, arguments);\r\n            } else  if (this.init) {\r\n                return this.init.apply(this, arguments);\r\n            }\r\n        }\r\n\r\n        return function createClass(props, parent, mixins,options) {\r\n            if (isArray(parent)) {\r\n                options = mixins;\r\n                mixins = parent;\r\n                parent = null;\r\n            }\r\n            parent = parent || Object;\r\n\r\n            if (isDefined(mixins) && !isArray(mixins)) {\r\n                options = mixins;\r\n                mixins = false;\r\n            }\r\n\r\n            var innerParent = parent;\r\n\r\n            if (mixins) {\r\n                mixins = serialMixins(innerParent,mixins);\r\n            }\r\n\r\n            if (mixins) {\r\n                innerParent = mergeMixins(innerParent,mixins);\r\n            }\r\n\r\n            var klassName = props.klassName || \"\",\r\n                ctor = new Function(\r\n                    \"return function \" + klassName + \"() {\" +\r\n                    \"var inst = this,\" +\r\n                    \" ctor = arguments.callee;\" +\r\n                    \"if (!(inst instanceof ctor)) {\" +\r\n                    \"inst = Object.create(ctor.prototype);\" +\r\n                    \"}\" +\r\n                    \"return ctor._constructor.apply(inst, arguments) || inst;\" + \r\n                    \"}\"\r\n                )();\r\n\r\n\r\n            // Populate our constructed prototype object\r\n            ctor.prototype = Object.create(innerParent.prototype);\r\n\r\n            // Enforce the constructor to be what we expect\r\n            ctor.prototype.constructor = ctor;\r\n            ctor.superclass = parent;\r\n\r\n            // And make this class extendable\r\n            ctor.__proto__ = innerParent;\r\n\r\n\r\n            if (!ctor._constructor) {\r\n                ctor._constructor = _constructor;\r\n            } \r\n\r\n            if (mixins) {\r\n                ctor.__mixins__ = mixins;\r\n            }\r\n\r\n            if (!ctor.partial) {\r\n                ctor.partial = function(props, options) {\r\n                    return extendClass(this, props, options);\r\n                };\r\n            }\r\n            if (!ctor.inherit) {\r\n                ctor.inherit = function(props, mixins,options) {\r\n                    return createClass(props, this, mixins,options);\r\n                };\r\n            }\r\n\r\n            ctor.partial(props, options);\r\n\r\n            return ctor;\r\n        };\r\n    }\r\n\r\n    var createClass = f1();\r\n\r\n    return createClass;\r\n})"]}