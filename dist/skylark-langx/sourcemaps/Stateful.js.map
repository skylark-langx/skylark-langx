{"version":3,"sources":["Stateful.js"],"names":["define","Evented","strings","objects","isEqual","mixin","result","isEmptyObject","clone","uniqueId","inherit","_construct","attributes","options","attrs","this","cid","cidPrefix","collection","parse","defaults","set","changed","validationError","idAttribute","toJSON","get","attr","has","key","val","_validate","unset","silent","changes","changing","_changing","_previousAttributes","current","prev","push","id","length","_pending","i","trigger","clear","hasChanged","undefined","changedAttributes","diff","old","previous","previousAttributes","constructor","isNew","isValid","validate","error"],"mappings":"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","file":"../Stateful.js","sourcesContent":["define([\r\n\t\"./Evented\",\r\n  \"./strings\",\r\n  \"./objects\"\r\n],function(Evented,strings,objects){\r\n    var isEqual = objects.isEqual,\r\n        mixin = objects.mixin,\r\n        result = objects.result,\r\n        isEmptyObject = objects.isEmptyObject,\r\n        clone = objects.clone,\r\n        uniqueId = strings.uniqueId;\r\n\r\n    var Stateful = Evented.inherit({\r\n        _construct : function(attributes, options) {\r\n            var attrs = attributes || {};\r\n            options || (options = {});\r\n            this.cid = uniqueId(this.cidPrefix);\r\n            this.attributes = {};\r\n            if (options.collection) this.collection = options.collection;\r\n            if (options.parse) attrs = this.parse(attrs, options) || {};\r\n            var defaults = result(this, 'defaults');\r\n            attrs = mixin({}, defaults, attrs);\r\n            this.set(attrs, options);\r\n            this.changed = {};\r\n        },\r\n\r\n        // A hash of attributes whose current and previous value differ.\r\n        changed: null,\r\n\r\n        // The value returned during the last failed validation.\r\n        validationError: null,\r\n\r\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n        // CouchDB users may want to set this to `\"_id\"`.\r\n        idAttribute: 'id',\r\n\r\n        // The prefix is used to create the client id which is used to identify models locally.\r\n        // You may want to override this if you're experiencing name clashes with model ids.\r\n        cidPrefix: 'c',\r\n\r\n\r\n        // Return a copy of the model's `attributes` object.\r\n        toJSON: function(options) {\r\n          return clone(this.attributes);\r\n        },\r\n\r\n\r\n        // Get the value of an attribute.\r\n        get: function(attr) {\r\n          return this.attributes[attr];\r\n        },\r\n\r\n        // Returns `true` if the attribute contains a value that is not null\r\n        // or undefined.\r\n        has: function(attr) {\r\n          return this.get(attr) != null;\r\n        },\r\n\r\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n        // the core primitive operation of a model, updating the data and notifying\r\n        // anyone who needs to know about the change in state. The heart of the beast.\r\n        set: function(key, val, options) {\r\n          if (key == null) return this;\r\n\r\n          // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n          var attrs;\r\n          if (typeof key === 'object') {\r\n            attrs = key;\r\n            options = val;\r\n          } else {\r\n            (attrs = {})[key] = val;\r\n          }\r\n\r\n          options || (options = {});\r\n\r\n          // Run validation.\r\n          if (!this._validate(attrs, options)) return false;\r\n\r\n          // Extract attributes and options.\r\n          var unset      = options.unset;\r\n          var silent     = options.silent;\r\n          var changes    = [];\r\n          var changing   = this._changing;\r\n          this._changing = true;\r\n\r\n          if (!changing) {\r\n            this._previousAttributes = clone(this.attributes);\r\n            this.changed = {};\r\n          }\r\n\r\n          var current = this.attributes;\r\n          var changed = this.changed;\r\n          var prev    = this._previousAttributes;\r\n\r\n          // For each `set` attribute, update or delete the current value.\r\n          for (var attr in attrs) {\r\n            val = attrs[attr];\r\n            if (!isEqual(current[attr], val)) changes.push(attr);\r\n            if (!isEqual(prev[attr], val)) {\r\n              changed[attr] = val;\r\n            } else {\r\n              delete changed[attr];\r\n            }\r\n            unset ? delete current[attr] : current[attr] = val;\r\n          }\r\n\r\n          // Update the `id`.\r\n          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\r\n\r\n          // Trigger all relevant attribute changes.\r\n          if (!silent) {\r\n            if (changes.length) this._pending = options;\r\n            for (var i = 0; i < changes.length; i++) {\r\n              this.trigger('change:' + changes[i], this, current[changes[i]], options);\r\n            }\r\n          }\r\n\r\n          // You might be wondering why there's a `while` loop here. Changes can\r\n          // be recursively nested within `\"change\"` events.\r\n          if (changing) return this;\r\n          if (!silent) {\r\n            while (this._pending) {\r\n              options = this._pending;\r\n              this._pending = false;\r\n              this.trigger('change', this, options);\r\n            }\r\n          }\r\n          this._pending = false;\r\n          this._changing = false;\r\n          return this;\r\n        },\r\n\r\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n        // if the attribute doesn't exist.\r\n        unset: function(attr, options) {\r\n          return this.set(attr, void 0, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Clear all attributes on the model, firing `\"change\"`.\r\n        clear: function(options) {\r\n          var attrs = {};\r\n          for (var key in this.attributes) attrs[key] = void 0;\r\n          return this.set(attrs, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Determine if the model has changed since the last `\"change\"` event.\r\n        // If you specify an attribute name, determine if that attribute has changed.\r\n        hasChanged: function(attr) {\r\n          if (attr == null) return !isEmptyObject(this.changed);\r\n          return this.changed[attr] !== undefined;\r\n        },\r\n\r\n        // Return an object containing all the attributes that have changed, or\r\n        // false if there are no changed attributes. Useful for determining what\r\n        // parts of a view need to be updated and/or what attributes need to be\r\n        // persisted to the server. Unset attributes will be set to undefined.\r\n        // You can also pass an attributes object to diff against the model,\r\n        // determining if there *would be* a change.\r\n        changedAttributes: function(diff) {\r\n          if (!diff) return this.hasChanged() ? clone(this.changed) : false;\r\n          var old = this._changing ? this._previousAttributes : this.attributes;\r\n          var changed = {};\r\n          for (var attr in diff) {\r\n            var val = diff[attr];\r\n            if (isEqual(old[attr], val)) continue;\r\n            changed[attr] = val;\r\n          }\r\n          return !isEmptyObject(changed) ? changed : false;\r\n        },\r\n\r\n        // Get the previous value of an attribute, recorded at the time the last\r\n        // `\"change\"` event was fired.\r\n        previous: function(attr) {\r\n          if (attr == null || !this._previousAttributes) return null;\r\n          return this._previousAttributes[attr];\r\n        },\r\n\r\n        // Get all of the attributes of the model at the time of the previous\r\n        // `\"change\"` event.\r\n        previousAttributes: function() {\r\n          return clone(this._previousAttributes);\r\n        },\r\n\r\n        // Create a new model with identical attributes to this one.\r\n        clone: function() {\r\n          return new this.constructor(this.attributes);\r\n        },\r\n\r\n        // A model is new if it has never been saved to the server, and lacks an id.\r\n        isNew: function() {\r\n          return !this.has(this.idAttribute);\r\n        },\r\n\r\n        // Check if the model is currently in a valid state.\r\n        isValid: function(options) {\r\n          return this._validate({}, mixin({}, options, {validate: true}));\r\n        },\r\n\r\n        // Run validation against the next complete set of model attributes,\r\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\r\n        _validate: function(attrs, options) {\r\n          if (!options.validate || !this.validate) return true;\r\n          attrs = mixin({}, this.attributes, attrs);\r\n          var error = this.validationError = this.validate(attrs, options) || null;\r\n          if (!error) return true;\r\n          this.trigger('invalid', this, error, mixin(options, {validationError: error}));\r\n          return false;\r\n        }\r\n    });\r\n\r\n\treturn Stateful;\r\n});"]}