{"version":3,"sources":["Stateful.js"],"names":["define","Evented","strings","objects","isEqual","mixin","result","isEmptyObject","clone","uniqueId","inherit","_construct","attributes","options","attrs","defaults","this","cid","cidPrefix","collection","parse","set","changed","validationError","idAttribute","toJSON","get","attr","has","key","val","_validate","unset","silent","changes","changing","_changing","current","_previousAttributes","prev","push","id","length","_pending","i","trigger","clear","hasChanged","undefined","changedAttributes","diff","old","previous","previousAttributes","constructor","isNew","isValid","validate","error"],"mappings":"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","file":"../Stateful.js","sourcesContent":["define([\r\n\t\"./Evented\",\r\n  \"./strings\",\r\n  \"./objects\"\r\n],function(Evented,strings,objects){\r\n    var isEqual = objects.isEqual,\r\n        mixin = objects.mixin,\r\n        result = objects.result,\r\n        isEmptyObject = objects.isEmptyObject,\r\n        clone = objects.clone,\r\n        uniqueId = strings.uniqueId;\r\n\r\n    var Stateful = Evented.inherit({\r\n        _construct : function(attributes, options) {\r\n            var attrs = attributes || {};\r\n            options || (options = {});\r\n            this.cid = uniqueId(this.cidPrefix);\r\n            this.attributes = {};\r\n            if (options.collection) this.collection = options.collection;\r\n            if (options.parse) attrs = this.parse(attrs, options) || {};\r\n            var defaults = result(this, 'defaults');\r\n            attrs = mixin({}, defaults, attrs);\r\n            this.set(attrs, options);\r\n            this.changed = {};\r\n        },\r\n\r\n        // A hash of attributes whose current and previous value differ.\r\n        changed: null,\r\n\r\n        // The value returned during the last failed validation.\r\n        validationError: null,\r\n\r\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n        // CouchDB users may want to set this to `\"_id\"`.\r\n        idAttribute: 'id',\r\n\r\n        // The prefix is used to create the client id which is used to identify models locally.\r\n        // You may want to override this if you're experiencing name clashes with model ids.\r\n        cidPrefix: 'c',\r\n\r\n\r\n        // Return a copy of the model's `attributes` object.\r\n        toJSON: function(options) {\r\n          return clone(this.attributes);\r\n        },\r\n\r\n\r\n        // Get the value of an attribute.\r\n        get: function(attr) {\r\n          return this.attributes[attr];\r\n        },\r\n\r\n        // Returns `true` if the attribute contains a value that is not null\r\n        // or undefined.\r\n        has: function(attr) {\r\n          return this.get(attr) != null;\r\n        },\r\n\r\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n        // the core primitive operation of a model, updating the data and notifying\r\n        // anyone who needs to know about the change in state. The heart of the beast.\r\n        set: function(key, val, options) {\r\n          if (key == null) return this;\r\n\r\n          // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n          var attrs;\r\n          if (typeof key === 'object') {\r\n            attrs = key;\r\n            options = val;\r\n          } else {\r\n            (attrs = {})[key] = val;\r\n          }\r\n\r\n          options || (options = {});\r\n\r\n          // Run validation.\r\n          if (!this._validate(attrs, options)) return false;\r\n\r\n          // Extract attributes and options.\r\n          var unset      = options.unset;\r\n          var silent     = options.silent;\r\n          var changes    = [];\r\n          var changing   = this._changing;\r\n          this._changing = true;\r\n\r\n          if (!changing) {\r\n            this._previousAttributes = clone(this.attributes);\r\n            this.changed = {};\r\n          }\r\n\r\n          var current = this.attributes;\r\n          var changed = this.changed;\r\n          var prev    = this._previousAttributes;\r\n\r\n          // For each `set` attribute, update or delete the current value.\r\n          for (var attr in attrs) {\r\n            val = attrs[attr];\r\n            if (!isEqual(current[attr], val)) changes.push(attr);\r\n            if (!isEqual(prev[attr], val)) {\r\n              changed[attr] = val;\r\n            } else {\r\n              delete changed[attr];\r\n            }\r\n            unset ? delete current[attr] : current[attr] = val;\r\n          }\r\n\r\n          // Update the `id`.\r\n          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\r\n\r\n          // Trigger all relevant attribute changes.\r\n          if (!silent) {\r\n            if (changes.length) this._pending = options;\r\n            for (var i = 0; i < changes.length; i++) {\r\n              this.trigger('change:' + changes[i], this, current[changes[i]], options);\r\n            }\r\n          }\r\n\r\n          // You might be wondering why there's a `while` loop here. Changes can\r\n          // be recursively nested within `\"change\"` events.\r\n          if (changing) return this;\r\n          if (!silent) {\r\n            while (this._pending) {\r\n              options = this._pending;\r\n              this._pending = false;\r\n              this.trigger('change', this, options);\r\n            }\r\n          }\r\n          this._pending = false;\r\n          this._changing = false;\r\n          return this;\r\n        },\r\n\r\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n        // if the attribute doesn't exist.\r\n        unset: function(attr, options) {\r\n          return this.set(attr, void 0, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Clear all attributes on the model, firing `\"change\"`.\r\n        clear: function(options) {\r\n          var attrs = {};\r\n          for (var key in this.attributes) attrs[key] = void 0;\r\n          return this.set(attrs, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Determine if the model has changed since the last `\"change\"` event.\r\n        // If you specify an attribute name, determine if that attribute has changed.\r\n        hasChanged: function(attr) {\r\n          if (attr == null) return !isEmptyObject(this.changed);\r\n          return this.changed[attr] !== undefined;\r\n        },\r\n\r\n        // Return an object containing all the attributes that have changed, or\r\n        // false if there are no changed attributes. Useful for determining what\r\n        // parts of a view need to be updated and/or what attributes need to be\r\n        // persisted to the server. Unset attributes will be set to undefined.\r\n        // You can also pass an attributes object to diff against the model,\r\n        // determining if there *would be* a change.\r\n        changedAttributes: function(diff) {\r\n          if (!diff) return this.hasChanged() ? clone(this.changed) : false;\r\n          var old = this._changing ? this._previousAttributes : this.attributes;\r\n          var changed = {};\r\n          for (var attr in diff) {\r\n            var val = diff[attr];\r\n            if (isEqual(old[attr], val)) continue;\r\n            changed[attr] = val;\r\n          }\r\n          return !isEmptyObject(changed) ? changed : false;\r\n        },\r\n\r\n        // Get the previous value of an attribute, recorded at the time the last\r\n        // `\"change\"` event was fired.\r\n        previous: function(attr) {\r\n          if (attr == null || !this._previousAttributes) return null;\r\n          return this._previousAttributes[attr];\r\n        },\r\n\r\n        // Get all of the attributes of the model at the time of the previous\r\n        // `\"change\"` event.\r\n        previousAttributes: function() {\r\n          return clone(this._previousAttributes);\r\n        },\r\n\r\n        // Create a new model with identical attributes to this one.\r\n        clone: function() {\r\n          return new this.constructor(this.attributes);\r\n        },\r\n\r\n        // A model is new if it has never been saved to the server, and lacks an id.\r\n        isNew: function() {\r\n          return !this.has(this.idAttribute);\r\n        },\r\n\r\n        // Check if the model is currently in a valid state.\r\n        isValid: function(options) {\r\n          return this._validate({}, mixin({}, options, {validate: true}));\r\n        },\r\n\r\n        // Run validation against the next complete set of model attributes,\r\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\r\n        _validate: function(attrs, options) {\r\n          if (!options.validate || !this.validate) return true;\r\n          attrs = mixin({}, this.attributes, attrs);\r\n          var error = this.validationError = this.validate(attrs, options) || null;\r\n          if (!error) return true;\r\n          this.trigger('invalid', this, error, mixin(options, {validationError: error}));\r\n          return false;\r\n        }\r\n    });\r\n\r\n\treturn Stateful;\r\n});"]}